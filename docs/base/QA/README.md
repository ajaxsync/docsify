<!-- 
* 该文件是子目录的路由默认页
* 默认不显示目录，可以设置开启侧边栏的目录显示，该文件的目录会显示在侧边栏
* 侧边栏默认显示的一级目录，是通过根目录的_sidebar.md文件定义的。
* 嵌套目录显示是从二级目录开始的，subMaxLevel: 5 能够显示到四级目录
-->

# QA
>  [首页](/) | [HTML](/base/html/) | [CSS](/base/css/) | [JavaScript](/base/js/)

## JavaScript

### 类型转换

> 什么情况下会出现undefined？
```
    1- 变量声明未赋值
    2- 使用typeof 检测一个 不存在的变量
    3- 函数未return时，执行结果为undefined
    4- 使用void操作任何值返回的都是undefined
    参考：https://blog.csdn.net/Y2919164085/article/details/121027523

    补充：
    5- [函数的参数]函数只有形参时，在函数内部使用该参数时，结果会是undefined
    6- [作用域]当我们访问一个变量时，会优先在自身作用域查找，如果没有会继续向上一级作用域查找，一直找到全局作用域，如果依旧没有，会报错（xx is not defined）
```

> 什么情况下会出现NaN?
```
常发生在数据类型转换时，如：
    1- String，如果是一个非纯数字的字符串，转Number类型
    2- undefined，转Number类型
```

> 其他类型转String注意点
```
    undefined与null只能使用 String() 进行转换
    Number、Boolean可以使用 String()、toString() 进行转换

    数据.toString(进制)，转进制时，数据为Number才会生效
```

### 运算符

#### 一元运算符

> 自增自减运算符，i++ 和 ++i 是什么区别？
```js
    // i++ 表示先使用，再自增
    // ++i 表示先自增，再使用

    var a = 5
    console.log(++a + a++ + a-- + a + a-- + --a);  // 35

    var b = -3
    console.log(--b + b-- + b++ + b + --b + ++b );  // -26
```

#### 二元运算符

> 数学运算注意点
```js
+ - * / %

需要注意的是：加法
    var a = 5
    var b = '2'

    // 加法运算，如果运算中出现了字符串。  会先将变量转为String，然后拼接。
    console.log(a+b);  // '52'

其他运算符
    // 其他运算，会先将变量转为 Number  再计算
    console.log(a-b);  // 3

    取余运算，一般用来判断奇数偶数，或是某个数的倍数
```

> 赋值运算符
```js
= += -= /= %=

其实：
a+=b  ==>  a=a+b
```

> 比较运算符 
```js
> = <= == ===

比较运算符实际比较的是：值（隐式转换为Number）

注意：
    * 如果比较的两边，是两个字符串，不会转Number比较
    * 而是按照字符串中对应的字符在编码表（UTF-16）中的数值的大小来进行比较的

等于的比较：
    * ==  仅比较值
    * === 即比较类型，也比较值
```

> 逻辑运算符
```js
&& || ！  // 运算符两边是布尔值进行比较

&&  表示两个条件必须同时满足，返回true
||  表示两个条件只要一个满足，返回false
！  表示取反，true变为false  false变为true
```

#### 三元运算符
```js
其实就相当于简单的判断

A ? B : C
条件 ? 表达式1 : 表达式2

如果条件满足，执行表达式1，不满足就执行表达式2
```


### 分支与循环

#### 分支
> 分支注意点
```js
// 分支也叫判断/选择
+ if else  
    单分支
        if(条件){
            // 代码
        }
    
    双分支
        if(条件){
            // 代码
        }else{
            // 代码
        }

    多分支
        if(条件) {
            // 代码
        }else if(条件) {
            // 代码
        } else if(条件) {
            // 代码
        } else {
            // 代码
        }

+ switch case
    switch (值) {
        case 场景值1：
            // 代码1;
        case 场景值2：
            // 代码3;
        case 场景值3：
            // 代码3;
        ···
        default:
            // 都不满足时执行的代码
    }

    * switch 的值与 case的场景值是全等的关系 （===）
    * 在case的代码片段中，如果没写 break 会有穿透效果

注意：
    * if 的条件是一个范围
    * switch 的条件是固定值
```


#### 循环

> 循环的注意点
```js
    // JS中有3种基础的循环，while、do···while、for

    // >> do···while与while的区别是什么？
    //     - 前者是无论如何先执行一次在进行判断，后者会直接进行判断。

    // >> continue 和 break 的区别是什么？
    //     - continue 是跳过本次循环
    //     - break 是直接跳出当前循环
        
    for(var i=1;i<=6;i++){
        if(i==3){
            continue;  // 吃到第三个包子的时候，包子掉地上不能吃了，接着吃后面的包子
            break;     // 吃到第三个包子的时候，已经吃饱了不能吃了，后面的包子就都不吃了
        }
        console.log("我吃第"+i+"个包子");
    }

```

### 函数

> 函数的两种声明方式的区别是什么？
```js
函数的声明：
    // 声明式
    function fn() {}
    // 赋值式
    var fn1 = function() {}

函数调用：
    * 两种方式定义的函数，调用方式均是：函数名()
    * 区别：
        - 声明式函数可以在声明之前调用
        - 赋值式只能在声明后调用，否则会报错： xx is not a function 
        - 原因：和"预解析"有关

函数的命名：
   * 函数的命名规则与变量的命名规则相同

函数定义阶段做了哪些儿事？
    1. 先在（堆）开辟一个空间，并得到（堆）空间的地址
    2. 然后把代码当成一个字符串，存放到（堆）空间里面
    3. 最后，把这个空间的地址，赋值给函数名
    // 函数属于复杂数据类型，所以与复杂数据类型的赋值逻辑类似
```

> 函数的参数
```js
+ 函数的参数有两种，形参与实参，写法如下：
    * 声明式
        function fn(形参1, 形参2, 形参3···){
            // 代码
        }
        fn(实参1, 实参2, 实参3···)

    * 赋值式
        var fn2 = function(形参1, 形参2, 形参3···){
            // 代码
        }
        fn2(实参1, 实参2, 实参3···)

+ 形参
    - 形参是在函数内部可以使用的变量，在函数外部不能使用
    - 形参的值是在函数调用的时候由实参决定的，实参为形参赋值
    - 如果形参未被赋值，函数内部拿到的时候，结果为undefined
    - 比如：需要传递name、age两个参数，但只传了name，函数内部的age就为 undefined
+ 实参
    - 实参一般是一个具体的值，在函数调用的时候，给形参进行赋值
    - 函数内部形参的值，是由函数调用的时候，传递的实参所决定的

+ 参数个数问题
    - 形参与实参是一一对应的
    - 如果 形参 > 实参，那么多余的形参由于未赋值，结果为undefined
    - 如果 实参 > 形参，那么由于函数内部仅能使用的是形参，所以多传递的实参无用，函数内部也拿不到

+ 补充：arguments
    - 每一个函数内部都有一个arguments对象
    - 他可以记录函数调用的时候传递实参的信息（是个数组，使用arguments[index]）
```

> 函数`return`的相关问题
```js
+ return 表示返回的意思，有两个作用：
    - 终断函数执行
    - 为函数提供一个返回值

    + 1 终断函数的执行
        - 函数内部的代码执行顺序，是从上到下，直到全部执行完
        - 如果在中途遇到了 return，那么后面的代码就不会执行了

        function fn(){
            console.log(1)
            console.log(2)
            console.log(3)
            // 写了return 以后，后面的就不会执行与输出了
            return;
            console.log(4);
            console.log(5)
        }


    + 2 函数的返回值
        - 函数本身就是一个表达式，表达式执行都是有结果的
        - 函数执行完以后，默认是不会有结果的，结果为undefined
        - 因此，使用 return 为函数执行完毕后，提供一个结果
    
        function fun(){
            console.log(1)
            console.log(2)
            console.log(3)
            return 10;  // 为函数执行完毕后提供一个结果
        }
        var res  = fun()
        console.log(res) // 10
```

> 预解析
```js
js是解释型语言，在执行代码之前会对代码进行通读。也就是先进行预解析，然后再执行

+ 预解析会做什么？
    - 1 将 声明式函数 提前定义
    - 2 将 var 声明的变量 提前定义
    * 由此可以解释，为什么声明式函数可以在定义之前调用，而赋值式函数不行

    fn()  // 我是函数fn()
    console.log(num)  // undefined

    function fn() {
        console.log('我是函数fn()')
    }
    var num = 2022;


    说明：js在执行的时候，会先进行预解析
        - 在内存中声明一个变量 fn，知道里面的内容是一个函数
        - 在内存中声明一个变量 num，但不会赋值，所以是undefined

+ 预解析优先级
    - 如果函数名与变量名相同，会优先解析函数
    - 因为在JS中函数是头等公民，所以函数的预解析优先级高于变量

    console.log( func );  // 函数体
    var func = 123;
    console.log( func );  // 123
    function func() {
        console.log( 'Hello js' );
    }
```

> 作用域
```js
含义：一个变量可以起作用的范围，叫作用域

分类：全局作用域、局部作用域
    + 全局作用域是最大的作用域，如全局作用域window
        - 全局作用域声明的变量，在全局的任何地方均可使用
    + 局部作用域是定义在函数内部的
        - 每一个函数，都是一个局部作用域
        - 局部作用域声明的变量，只能在函数内部使用

变量的使用规则：
    + 访问规则
        - 当我们需要获取一个变量，就叫访问
        - 首先会在自身作用域查找，如果有就直接用，没有的话会向上一级作用域进行查找，一直找到全局作用域，如果依旧没有，就会报错（xx is not defined）
    + 赋值规则
        - 当我们需要给一个变量赋值，就需要先查找这个变量，然后再给变量赋值
        - 先会在自身作用域查找，如果有就直接赋值，如果没有会继续向上一级作用域查找，一直找到全局作用域，如果依旧没有，就会将该变量声明为全局变量，然后再赋值

```

> 递归函数
```js
含义：函数自己调用自己
    递归函数与循环类似，需要有初始化，自增，执行代码，条件判断，否找就是死递归
    
    function fn(){
        fn()   // 没有终止条件，是死递归
    }
    fn()

    示例：求任意数到1的累加和
    function getSum(num){
        if(num==1){
            return 1;  // 终止条件
        }else{
            return num + getSum(num-1)  // 终止条件
        }
    }
    getSum(100)  // 5050

Try it：求斐波那契数列的任意位置的值
```

### 对象

> 初识对象
```js
引入：
    * JS有两大数据类型
    * 简单/基本/原始数据类型、复杂/引用数据类型

含义：
    * 对象是JS中的一种数据类型，属于复杂数据类型，用来存复杂数据的
    * 以键值对的方式存储数据，里面存储的是一些数据的集合
    * 对象的{}中的每一个键，都是其内部的一个成员，他们之间互不影响
    
涉及到数据的存储方式：
    - JS存储数据有两个地方，栈和堆
    - 简单数据类型，是存储在栈里
    - 复杂数据类型，是存储在堆里，然后将堆的地址保存在栈里，通过地址再去找数据

    - 比喻1：
        * 假如对象是个房子，可以把数据存放在房子里，再把地址赋值给变量名
        * 需要取数据的时候，只要根据变量名保存的地址去内存中查找即可
    - 比喻2：
        * 栈可以理解为你能随身携带的口袋、书包、行李箱，变量可以理解为手机、钥匙···
        * 堆可以理解为你不必要或不能随身携带的，比如房子，数据可以理解为脸盆、牙刷，桌椅板凳···
        * 复杂数据类型，实际就是把数据放在一个房间里，然后你有这个房间的地址和钥匙（变量名，如obj）
        * 最后你把钥匙（obj）揣在口袋随身携带，当你需要洗脸刷牙的时候，可以拿着钥匙打开房间，找到脸盆、牙刷，洗脸刷牙即可。
    ==> 比喻是个人理解，仅供参考

对象的创建：
    + 字面量：
        - var obj1 = {}  // 直接创建一个空对象
        - var obj1 = {   // 创建一个有初始值的对象
            name: "张三",
            age: 18
        }
        
    + 内置构造函数：
        - var obj2 = new Object()  // 仅创建一个空对象

向对象中添加数据：
    + 使用点语法：obj.data = "2022-12-12"  // obj.key = value
    + 使用类数组法：obj['name'] = "李四"  // obj['key'] = value
    + key是对象的属性，value是属性值  // { key1: value1, key2: value2, ··· }

使用对象：
    + 点语法：obj.key
    + 类数组法：obj['key']
    * 注意：
        - [常用]当对象的键是一个具体的值（已知对象中有这个key），就用 obj.key
        - 若对象的键不是一个具体的值，可以使用obj['key']，但key记得加引号
        - 如形参中的arguments，使用时：arguments[index]，数字不用加引号

    * 删除数据
        - delete obj.key  // 会把对象里面某个键值对删除（属性与属性值都同时删除，不常用）
```

> 初识常用的交互
```js
// 为标签设置id后，可以直接使用id名获取该元素
    <div id="box"></div>
    box.innerHTML = "hello world"  // 可以获取这个div 并向div中写入值

+ 常用
    - 鼠标点击: onclick
    - 鼠标移入: onmouseover
    - 鼠标移出: onmouseout
    - 文本框内容改变: onchange

+ 修改内容
    - 向页面写入内容：innerText（仅转为字符串）、innerHTML（可识别html标签）
    - 改变输入框的值：元素.value = "值"
    - 修改元素的自带属性：
        * 元素.属性名 = 属性值，注意：class需改为className
        * 元素.backgroundColor = "red"，注意：如果属性名有-，改为大驼峰
```

### 数组

#### 数组基础

```js
含义：数组是一个有序的数据集合，下标从0开始

JS数据类型分类：
    + 简单数据类型：number、string、boolean、undefined、null
    + 复杂数据类型：function、object、array


数组的创建：
    + 字面量：
        - var arr = []  // 创建一个空数组
        - var arr = [1,2,3,4]  // 创建一个有内容的数组
    + 内置构造函数：
        - var arr = new Array() // 创建一个空数组
        - var arr = new Array(10) // 创建一个长度为10位的数组，值为 undefined
        - var arr = new Array(10, 56, 34) // 创建一个有内容/值的数组
        - var arr = new Array('10') // 创建一个值是字符串10的数组，参数是一个number才是数组长度

数组的length：
    - length 表示长度的意思
    - 数组有多少个值/成员，数组的长度就是多少
    - 语法：arr.length

数组的索引：
    - 索引也叫下标，常用 index 表示，是指一个数据在数组中排在哪一个位置
    - 注意: 在所有语言里面，索引都是从0开始的
    - 索引与数组长度的关系： index = length - 1
        * 如果某个元素的索引为-1，说明不是这个数组中的成员
    - 获取数组的某个元素：
        * 第一个元素是 arr[0] 
        * 最后一个元素是 arr[length-1]


引申并强调：数据类型之间存储的区别

    + JS数据类型的存储方式：栈、堆
        - 栈：存储基础数据类型
            * 直接在栈空间内存储一个数据
        - 堆：存储复杂数据类型
            * 先在堆里面开辟一个存储空间
            * 然后把数据存储在这个存储空间中
            * 最后把堆存储空间的地址赋值给栈里面的变量
    
    + 数据类型之间的比较：
        - 基本数据类型比较的是"值"，相互之间赋值时叫"值传递"
        - 复杂数据类型比较的是"地址"，相互之间赋值时叫"引用/地址传递"

    + 两种数据类型赋值举例：
        - 简单数据类型
            * 举例：
              var a1 = 10;
              var a2 = a1;
              console.log(a1==a2)  // true  
              // 将a1的值复制了一份给a2
              a1 = 20;
              console.log(a1, a2)  // 20  10
              // 即使更改了a1的值为20，a2的值依旧是10，两者互不影响

        - 复杂数据类型
            * 举例：
            var arr1 = { name: 'tim' }
            var arr2 = arr1  // 实际是将arr1的地址赋值给了arr2
            arr2.age = 20  // 实际会改变同一个地址里的值
            console.log(arr1, arr2)  // 两个打印的结果都会有 name与age属性
            console.log(arr1==arr2)  // true  比较的是同一个地址

    + 两种数据类型作为函数参数
        - 简单数据类型
            * 举例：
                var a = 10; // 1、定义了一个变量a
                function fn(b){
                    b++;  // 11   3、b=10 b++ = 11
                }
                fn(a);  // 2、将变量a的值赋值给b，相当于复制了一份给b
                console.log(a); // 10  4、b的变化不会影响a

        - 复杂数据类型
            * 举例：
                var m = [1,2,3,4];  // 1、定义了一个数组m
                function fn2(n){
                    n[n.length] = "hello" // 3、n得到的是m的地址，修改时会改变m的值
                }
                fn2(m);  //  2、m保存的是地址，所以是将地址复制了一份给n
                console.log(m);  // 4、n新增了数据，所以m的值也会变 [1,2,3,4, "hello"]


    + 我的比喻：
        - 相当于你租了一个房子，然后你同学想与你合租
        - 于是你把自己的钥匙配了一把给他
        - 所以你们都可以打开这个房子
        - 因此，如果你的同学买了一盆绿植
        - 当你回来的时候，会发现房间比之前多了一盆绿植

    + 总结：
        * 简单数据类型赋值，两者互不影响，一个变化另一个不会变
        * 复杂数据类型赋值，会受影响，一个变化另一个也会变化
```

#### 数组的常用方法

```js
【ES3中的常用方法】
首末增删：
    1 push
        * 功能:在数组末尾追加元素
        * 参数:arr.push(元素1,元素2,...)
        * 返回值:追加完以后数组的长度
        * 会改变原数组
    2 unshift
        * 功能:在数组前面追加元素
        * 参数:arr.unshift(元素1,元素2,...)
        * 返回值:追加完以后数组的长度
        * 会改变原数组
    3 shift
        * 功能:删除数组最前面的一个元素
        * 参数:arr.shift()
        * 返回值:被删除的元素
        * 会改变原数组
    4 pop
        * 功能:删除数组最后面的一个元素
        * 参数:arr.pop()
        * 返回值:被删除的元素
        * 会改变原数组


数组裁剪/反转/排序：
    5 splice
        * 功能:按照索引截取数组中的某些内容，可实现数组裁剪、删除、替换
        * 参数:arr.splice(从那个索引位置开始,截取多少个[,替换的新元素,...]),第三个参数可以不写
        * 返回值:被截取（删除）的内容的集合，是一个数组
        * 会改变原数组
        * 用法总结：
             + 独立门户，[返回值]截取后的返回值可以作为一个新的数组，使用被截取的内容
             + 扫地出门，[原数组]截取后，会改变原数组，从原数组中删除了不要的内容
             + 女娲补天，[原数组]在截取/删除的同时，还可以添加新的元素，所以相当于替换内容

    6 reverse
        * 功能:反转数组
        * 参数:arr.reverse()
        * 返回值:反转后的数组
        * 会改变原数组
            var arr1 = [1,2,3,4,5,6]
            var arr2 = arr1.reverse()  // 一般不关心返回值
            console.log(arr1);  // [6,5,4,3,2,1] 直接使用原数组
            console.log(arr2);  // [6,5,4,3,2,1]
            console.log(arr1==arr2);  // true

    7 sort
        * 功能:对数组元素进行排序
        * 参数:arr.sort([定义排序规则的函数]) 
        * 会改变原数组
        * 默认把数组元素转字符串，再按照字符串编码UTF-16进行排序
        * 补充知识：
               - 数字 < 大写字母 < 小写字母  可以参考：ASCII码表
               - 数字是字符串形式，仅比较第一位哦（范围是0-9）
        
        var arr = [21,2,15,65,87,99,32,77,45]
        arr.sort(function(){
            return a-b; // 从小到大排序
            return b-a; // 从大到小排序
        })

        举个栗子：
        // 将班级同学按照身高从大到小排序
        var myClass = [
            {
                name:"张三",
                score:100,
                weight:50,
                height:170
            },
            {
                name:"李四",
                score:10,
                weight:100,
                height:180
            },
            {
                name:"王五",
                score:20,
                weight:40,
                height:175
            },
            {
                name:"赵六",
                score:78,
                weight:120,
                height:190
            }
        ]

        myClass.sort(function(a,b){
            // 排序需要有个能够比较大小的参照，如身高、体重、成绩
            return b.height-a.height;  // a、b是对象，用点语法获取对应的值
        })


数组拼接：
    8 concat
        * 功能:把多个数组进行拼接
        * 参数:arr1.concat(arr2,arr3,...)
        * 返回值:拼接好的新数组
        * 不会改变原数组，而是产生一个新数组

        var arr1 = [1,2,3,4]
        var arr2 = ['你好','世界']
        var arr3 = arr1.concat(arr2)
        console.log(arr1);  // [1,2,3,4]
        console.log(arr2);  // ['你好','世界']
        console.log(arr3);  // [1,2,3,4,'你好','世界']


    9 join
        * 功能:把数组里的每一个元素连接起来，变成一个字符串[数组==>字符串]
        * 参数:arr.join("连接符号") ，如果不写"连接符号"，默认是逗号
        * 返回值:拼接好的字符串
        * 不会改变原数组
    
    数组拼接总结：
        * concat 是将所有数组中的元素取出，放在一个新数组并返回[新数组]
        * join 是将数组中的元素，通过连接符拼接成一个字符串并返回[字符串]
        * concat、join 都不会改变原数组


【ES5中的新增方法】
    1 indexOf
        + 作用:用来查找数组中某个元素的索引
        + 语法:arr.indexOf('要查找数组中的某个元素')
        + 返回值:找到的第一个元素的索引，数值类型，没找到返回-1

    2 lastIndexOf
        + 作用:用来查找数组中某个元素的索引，但是从后往前找
        + 语法:arr.indexOf('要查找数组中的某个元素')
        + 返回值:找到的第一个元素的索引，数值类型，没找到返回-1

    3 forEach
        + 作用:和for循环一样，用来遍历数组的
        + 语法:arr.forEach(function(item, index){
            // arr里面有几个元素，该函数就会执行几次
            // 函数里的形参item，代表本次循环到的元素的值
            // 函数里面的形参index，代表本次循环到的元素的索引
        })
    
    4 map
        + 作用:和forEach类似，只不过可以对数组的每一项进行操作，返回一个新的数组
        + 语法:arr.map(function(item, index){
            // arr里面有几个元素，该函数就会执行几次
            // 函数里的形参item，代表本次循环到的元素的值
            // 函数里面的形参index，代表本次循环到的元素的索引

            // 这个作为参数的函数可以设置返回值
            return item*2;
        })    
        + 返回值:所有val组成一个新数组，就是map函数的返回值
    
    5 filter
        + 作用:和map类似，按照我们的条件筛选数组
        + 语法:arr.filter(function(item, index){
            // arr里面有几个元素，该函数就会执行几次
            // 函数里的形参item，代表本次循环到的元素的值
            // 函数里面的形参index，代表本次循环到的元素的索引
            
            // 这个作为参数的函数可以设置返回值，不管返回值是什么，都看成布尔值
            if(item>20) {
                return true;
            }
        })
        + 返回值:所有的数组元素，返回值是true的元素保留，是false的元素去除，形成一个新数组返回



```


#### 数组的排序

```js
就是将乱序的数组，进行有序的排列。若是深层次，其实就是与算法有关了。

常用的排序：
    - 冒泡排序
    - 选择排序


冒泡排序：
    - 循环遍历数组，比较相邻两个变量的大小，如果第一个大于第二个，就互换位置
    - 第一轮循环结束，那个数组最后一个元素就是最大的
    - 然后再进行下一轮循环，即外层再嵌套一个循环
    - 外层循环控制整体循环次数，内层循环控制每次比较次数
    - 优化：外层与内层循环的总次数可以都减1

    var arr = [3,1,5,6,9,7,2,8]
    // 一共需要循环几次
    for(var j=0;j<arr.length-1;j++){
        // 每次循环，最大的放在后面
        for(var i=0;i<arr.length-j-1;i++){
            // 判断:如果数组的前一个比后一个大，就换位置
            if(arr[i]>arr[i+1]){
                var temp = arr[i];
                arr[i] = arr[i+1];
                arr[i+1] = temp;
            }
        }
    }


选择排序：
    - 先假设最小元素的索引，如果有一个元素的索引比自己小，就替换原先的索引

    - 假设数组的第0个元素的索引是最小的元素 minIndex=0
    - 然后遍历数组，若是还有比自己小的元素，就替换 minIndex的值
    - 待数组遍历结束，找到索引最小的元素，将其换到第0个位置

    - 再进行第二轮遍历，此时假设最小元素的索引 minIndex=1
    - 然后继续遍历数组，若是有比自己小的元素，再次替换 minIndex的值
    - 待数组遍历结束，找到索引最小的元素，将其换到第1个位置


    var arr = [3,1,5,6,9,7,2,8]
    // 
    for(var j=0;j<arr.length;j++){
        var minIndex = j;
    // 1 先确定最小值的索引
    for(var i=j+1;i<arr.length;i++){
        if(arr[i]<arr[minIndex]){
            minIndex = i;
        }
    }
        // 2 交换位置，将最小值元素放在前面
        var temp = arr[minIndex];
        arr[minIndex] = arr[j];
        arr[j] = temp;
    }
```

### 遍历数组与对象
```js
遍历：就是获取数组或者是对象中的每个数据、键值对

可以使用 for和for...in循环

+ 遍历数组
    * 我们可以通过数组的索引获取数组的值
    * 其范围是从 0 到 arr.length-1
    * 使用for循环
        var arr = [1,2,3,4,5,6]
        for(var i=0;i<arr.length;i++) {
            console.log(arr[i]);  // 1 2 3 4 5 6
        }
    * 使用for...in循环
        var arr = [1,2,3,4,5,6]
        for(var i in arr) {
            // i 是索引 arr 是遍历的数组
            console.log(i);  // 1 2 3 4 5 6
        }

+ 遍历对象
    * 因为对象没有索引，所以不能使用for循环
    * 使用for...in循环
        var obj = {
            name: 'tim',
            age: 20
        }
        for(var i in obj) {
            // i 是对象的键  obj 是遍历的对象
            console.log(i,);  // name age 
            console.log(i, obj[i]);  // name tim ; age 20
        }
```

### 严格模式
```js
JS默认未开启严格模式，开启严格模式："use strict";

严格模式可以写在全局，也可以写在函数内部。
写在全局是针对所有代码进行严格检查，写在函数内部仅检查函数内部的代码。


严格模式的检查规则：
    * 声明变量必须有var关键字
          b = 20; // b is not defined

    * 函数的形参名不可以重复
          function fn(a,a){
            // "use strict";  // 为函数开启严格模式
            console.log(a,a)
          }
          fn(1,2); 
          // Duplicate parameter name not allowed in this context

    * 声明式函数，函数内部没有this
        + 在非严格模式下，声明式函数的函数内部 this是 window
        + 在严格模式下，声明式函数的函数内部 this是 undefined
            function fun(){
                console.log(this)
            }
            fun()
```


### this

```js
this 
    - 在全局指的是 window
    - 在函数内部指的是 window
    - 在时间函数指的是 事件源，绑定事件的那个元素/标签
```

### 字符串
```js
字符串的创建：
    + 字面量：var str = "你好，世界！"
    + 内置构造函数：var str = new String('hello world!')


拓展知识：
    ASCII字符集
        * 计算机只能存储：0101010 这样的二进制数据
        * 比如a-z、A-Z、0-9等内容，都是以二进制数字存储在计算机里的
        * 可以简单理解为：a-z、A-Z、0-9等内容，都有自己的编号
        * 然后计算机在存储的时候，存储的是这些编号
        * 当我们查看时，也是通过这些编号，然后解析成我们能看懂的内容
        * 因此就需要一个字符串和二进制的对照表，如ASCII码表
    
    Unicode编码
        * ASCII只有128个字符串的编码，由美国发明
        * 英文内容只是一些字母，所以够用，但对于世界是不够用的
        * 所以出现了unicode编码，也叫万国码/统一码
        * utf-8就是一种8位的unicode字符集，也是最常用的编码集
```


#### 字符串的常用方法
```js



```


>  [首页](/) | [HTML](/base/html/) | [CSS](/base/css/) | [JavaScript](/base/js/)

<hr>
<!-- 更新日期 -->

Powered by [docsify](https://docsify.js.org/) <span>|</span> 
Update: {docsify-updated} 