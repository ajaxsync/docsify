<!-- 
* 该文件是子目录的路由默认页
* 默认不显示目录，可以设置开启侧边栏的目录显示，该文件的目录会显示在侧边栏
* 侧边栏默认显示的一级目录，是通过根目录的_sidebar.md文件定义的。
* 嵌套目录显示是从二级目录开始的，subMaxLevel: 5 能够显示到四级目录
-->

# QA
>  [首页](/) | [HTML](/base/html/) | [CSS](/base/css/) | [JavaScript](/base/js/)

## JavaScript

### 类型转换

> 什么情况下会出现undefined？
```
    1- 变量声明未赋值
    2- 使用typeof 检测一个 不存在的变量
    3- 函数未return时，执行结果为undefined
    4- 使用void操作任何值返回的都是undefined
    参考：https://blog.csdn.net/Y2919164085/article/details/121027523

    补充：
    5- [函数的参数]函数只有形参时，在函数内部使用该参数时，结果会是undefined
    6- [作用域]当我们访问一个变量时，会优先在自身作用域查找，如果没有会继续向上一级作用域查找，一直找到全局作用域，如果依旧没有，会报错（xx is not defined）
```

> 什么情况下会出现NaN?
```
常发生在数据类型转换时，如：
    1- String，如果是一个非纯数字的字符串，转Number类型
    2- undefined，转Number类型
```

> 其他类型转String注意点
```
    undefined与null只能使用 String() 进行转换
    Number、Boolean可以使用 String()、toString() 进行转换

    数据.toString(进制)，转进制时，数据为Number才会生效
```

### 运算符

#### 一元运算符

> 自增自减运算符，i++ 和 ++i 是什么区别？
```js
    // i++ 表示先使用，再自增
    // ++i 表示先自增，再使用

    var a = 5
    console.log(++a + a++ + a-- + a + a-- + --a);  // 35

    var b = -3
    console.log(--b + b-- + b++ + b + --b + ++b );  // -26
```

#### 二元运算符

> 数学运算注意点
```js
+ - * / %

需要注意的是：加法
    var a = 5
    var b = '2'

    // 加法运算，如果运算中出现了字符串。  会先将变量转为String，然后拼接。
    console.log(a+b);  // '52'

其他运算符
    // 其他运算，会先将变量转为 Number  再计算
    console.log(a-b);  // 3

    取余运算，一般用来判断奇数偶数，或是某个数的倍数
```

> 赋值运算符
```js
= += -= /= %=

其实：
a+=b  ==>  a=a+b
```

> 比较运算符 
```js
> = <= == ===

比较运算符实际比较的是：值（隐式转换为Number）

等于的比较：
    * ==  仅比较值
    * === 即比较类型，也比较值
```

> 逻辑运算符
```js
&& || ！  // 运算符两边是布尔值进行比较

&&  表示两个条件必须同时满足，返回true
||  表示两个条件只要一个满足，返回false
！  表示取反，true变为false  false变为true
```

#### 三元运算符
```js
其实就相当于简单的判断

A ? B : C
条件 ? 表达式1 : 表达式2

如果条件满足，执行表达式1，不满足就执行表达式2
```


### 分支与循环

#### 分支
> 分支注意点
```js
// 分支也叫判断/选择
+ if else  
    单分支
        if(条件){
            // 代码
        }
    
    双分支
        if(条件){
            // 代码
        }else{
            // 代码
        }

    多分支
        if(条件) {
            // 代码
        }else if(条件) {
            // 代码
        } else if(条件) {
            // 代码
        } else {
            // 代码
        }

+ switch case
    switch (值) {
        case 场景值1：
            // 代码1;
        case 场景值2：
            // 代码3;
        case 场景值3：
            // 代码3;
        ···
        default:
            // 都不满足时执行的代码
    }

    * switch 的值与 case的场景值是全等的关系 （===）
    * 在case的代码片段中，如果没写 break 会有穿透效果
```


#### 循环

> 循环的注意点
```js
    // JS中有3种基础的循环，while、do···while、for

    // >> do···while与while的区别是什么？
    //     - 前者是无论如何先执行一次在进行判断，后者会直接进行判断。

    // >> continue 和 break 的区别是什么？
    //     - continue 是跳过本次循环
    //     - break 是直接跳出当前循环
        
    for(var i=1;i<=6;i++){
        if(i==3){
            continue;  // 吃到第三个包子的时候，包子掉地上不能吃了，接着吃后面的包子
            break;     // 吃到第三个包子的时候，已经吃饱了不能吃了，后面的包子就都不吃了
        }
        console.log("我吃第"+i+"个包子");
    }

```

### 函数

> 函数的两种声明方式的区别是什么？
```js
函数的声明：
    // 声明式
    function fn() {}
    // 赋值式
    var fn1 = function() {}

    // 两种方式定义的函数，调用方式一致：  函数名()
    // 但是  声明式可以在声明之前调用，赋值式必须在声明后调用（否则会报错： xx is not a function）
    // 原因是因为 预解析

函数的命名：
   * 函数的命名规则与变量的命名规则相同

函数定义阶段做了哪些儿事？
    1. 先开辟一个空间，并得到空间的地址
    2. 然后把代码当成一个字符串，存放到空间里面
    3. 最后，把这个空间的地址，赋值给函数名
    // 函数属于复杂数据类型，所做的事与复杂数据类型的赋值逻辑有关
```

> 函数的参数
```js
+ 函数的参数有两种，形参与实参，写法如下：
    * 声明式
        function fn(形参1, 形参2, 形参3···){
            // 代码
        }
        fn(实参1, 实参2, 实参3···)

    * 赋值式
        var fn2 = function(形参1, 形参2, 形参3···){
            // 代码
        }
        fn2(实参1, 实参2, 实参3···)

+ 形参
    - 形参是在函数内部可以使用的变量，在函数外部不能使用
    - 形参的值是在函数调用的时候由实参决定的，实参为形参赋值
    - 如果形参未被赋值，函数内部拿到的时候，结果为undefined
    - 比如：需要传递name、age两个参数，但只传了name，函数内部的age就为 undefined
+ 实参
    - 实参一般是一个具体的值，在函数调用的时候，给形参进行赋值
    - 函数内部形参的值，是由函数调用的时候，传递的实参所决定的

+ 参数个数问题
    - 形参与实参是一一对应的
    - 如果 形参 > 实参，那么多余的形参由于未赋值，结果为undefined
    - 如果 实参 > 形参，那么由于函数内部仅能使用的是形参，所以多传递的实参无用，函数内部也拿不到

+ 补充：arguments
    - 每一个函数内部都有一个arguments对象
    - 他可以记录函数调用的时候传递实参的信息（是个数组，使用arguments[index]）
```

> 函数`return`的相关问题
```js
+ return 表示返回的意思，有两个作用：
    - 终断函数执行
    - 为函数提供一个返回值

    + 1 终断函数的执行
        - 函数内部的代码执行顺序，是从上到下，直到全部执行完
        - 如果在中途遇到了 return，那么后面的代码就不会执行了

        function fn(){
            console.log(1)
            console.log(2)
            console.log(3)
            // 写了return 以后，后面的就不会执行与输出了
            return;
            console.log(4);
            console.log(5)
        }


    + 2 函数的返回值
        - 函数本身就是一个表达式，表达式执行都是有结果的
        - 函数执行完以后，默认是不会有结果的，结果为undefined
        - 因此，使用 return 为函数执行完毕后，提供一个结果
    
        function fun(){
            console.log(1)
            console.log(2)
            console.log(3)
            return 10;  // 为函数执行完毕后提供一个结果
        }
        var res  = fun()
        console.log(res) // 10
```

> 预解析
```js
js是解释型语言，在执行代码之前会对代码进行通读。也就是先进行预解析，然后再执行

+ 预解析的两个内容
    - 1 使用 声明式声明的函数  function fn() {}
    - 2 使用 var 声明的变量
    * 在JS中函数是头等公民，如果函数名与变量名相同，优先使用函数

    fn()  // 我是函数fn()
    console.log(num)  // undefined

    function fn() {
        console.log('我是函数fn()')
    }
    var num = 2022;
     
    说明：js在执行的时候，会先进行预解析
        - 在内存中声明一个变量 fn，知道里面的内容是一个函数
        - 在内存中声明一个变量 num，但不会赋值，所以是undefined

    + 预解析优先级
        - 如果函数名与变量名相同，会优先解析函数
        - 函数的预解析优先级高于变量，因为在JS中函数是头等公民

    console.log( func );  // 函数体
    var func = 123;
    console.log( func );  // 123
    function func() {
        console.log( 'Hello js' );
    }
```

> 作用域
```
含义：一个变量可以起作用的范围，叫作用域

分类：全局作用域、局部作用域
    + 全局作用域是最大的作用域，如全局作用域window
        - 全局作用域声明的变量在任何地方均可使用
    + 局部作用域是定义在函数内部的
        - 每一个函数，都是一个局部作用域
        - 局部作用域声明的变量只能在函数内部使用

变量的使用规则：
    + 访问规则
        - 当我们需要获取一个变量，就叫访问
        - 首先会在自身作用域查找，如果有就直接用，没有的话会向上一级作用域进行查找，一直找到全局作用域，如果依旧没有，就会报错（xx is not defined）
    + 赋值规则
        - 当我们需要给一个变量赋值，就需要先查找这个变量，然后再给变量赋值
        - 先会在自身作用域查找，如果有就直接赋值，如果没有会继续向上一级作用域查找，一直找到全局作用域，如果依旧没有，就会将该变量声明为全局变量，然后再赋值

```

> 递归函数
```js
含义：函数自己调用自己
    递归函数与循环类似，需要有初始化，自增，执行代码，条件判断，否找就是死递归
    
    function fn(){
        fn()   // 没有终止条件，是死递归
    }
    fn()

    示例：求任意数到1的累加和
    function getSum(num){
        if(num==1){
            return 1;  // 终止条件
        }else{
            return num + getSum(num-1)  // 终止条件
        }
    }
    getSum(100)  // 5050

Try it：求斐波那契数列的任意位置的值
```

### 对象

> 初识对象
```js
引入：
    * JS有两大数据类型
    * 简单/基本/原始数据类型、复杂/引用数据类型

含义：
    * 对象是JS中的一种数据类型，属于复杂数据类型，用来存复杂数据的
    * 以键值对的方式存储数据，里面存储的是一些基本数据类型的集合
    * 对象的{}中的每一个键，都是其内部的一个成员，他们之间互不影响
    * 比喻：
        - 假如对象是个房子，可以把数据存放在房子里，再把地址赋值给变量名
        - 需要取数据的时候，只要根据变量名保存的地址去内存中查找即可
    
涉及到数据的存储方式：
        - JS存储数据有两个地方，栈和堆
        - 简单数据类型，是存储在栈里
        - 复杂数据类型，是存储在堆里，然后将堆的地址保存在栈里，通过地址再去找数据
        - 比喻：
            - 栈可以理解为你能随身携带的，比如手机、钥匙···
            - 堆可以理解为你不必要或不能随身携带的，比如脸盆、牙刷，桌椅板凳···
            - 复杂数据类型，实际就是把他放在一个房间里，然后你有这个房间的地址和钥匙（变量名，如obj）
            - 最后你把钥匙（obj）揣在口袋随身携带，当你需要洗脸刷牙的时候，可以拿着钥匙打开房间，找到脸盆、牙刷，洗脸刷牙即可。没必要随身携带脸盆、牙刷（比喻不是特别恰当，仅作理解参考）


对象的创建：
    + 字面量创建：
        - var obj1 = {}  // 直接创建一个空对象
        - var obj1 = {   // 创建一个有初始值的对象
            name: "张三",
            age: 18
        }
        
    + 内置构造函数创建：
        - var obj2 = new Object()  // 仅创建一个空对象

向对象中添加数据：
    + 使用点语法：obj.data = "2022-12-12"  // obj.key = value
    + 使用类数组法：obj['name'] = "李四"  // obj['key'] = value
    + key是对象的属性，value是属性值  // { key1: value1, key2: value2, ··· }

使用对象：
    + 点语法：obj.key
    + 类数组法：obj['key']
    * 注意：
        - [常用]当对象的键是一个具体的值（已知对象中有这个key），就用 obj.key
        - 若对象的键不是一个具体的值，可以是=使用obj['key']，但key记得加引号
            - 如形参中的arguments，使用时：arguments[index]，数字不用加引号
    * 删除数据
        - delete obj.key  // 会把对象里面某个键值对删除（属性与属性值都同时删除，不常用）
```

> 初识常用的交互
```js
// 为标签设置id后，可以直接使用id名获取该元素
    <div id="box"></div>
    box.innerHTML = "hello world"  // 可以获取这个div 并向div中写入值

+ 常用
    - 鼠标点击: onclick
    - 鼠标移入: onmouseover
    - 鼠标移出: onmouseout
    - 文本框内容改变: onchange

+ 修改内容
    - 向页面写入内容：innerText（仅转为字符串）、innerHTML（可识别html标签）
    - 改变输入框的值：元素.value = "值"
    - 修改元素的自带属性：
        * 元素.属性名 = 属性值，注意：class需改为className
        * 元素.backgroundColor = "red"，注意：如果属性名有-，需要使用大驼峰
```

### 数组

```js
含义：数组是一个有序的数据集合，下标从0开始

JS数据类型分类：
    + 简单数据类型：number、string、boolean、undefined、null
    + 复杂数据类型：function、object、array


数组的创建：
    + 字面量：
        - var arr = []  // 创建一个空数组
        - var arr = [1,2,3,4]  // 创建一个有内容的数组
    + 内置构造函数：
        - var arr = new Array() // 创建一个空数组
        - var arr = new Array(10) // 创建一个长度为10位的数组，值为 undefined
        - var arr = new Array(10, 56, 34) // 创建一个有内容/值的数组
        - var arr = new Array('10') // 创建一个值是字符串10的数组，参数是一个number才是数组长度

数组的length：
    - length 表示长度的意思
    - 数组有多少个值/成员，数组的长度就是多少
    - 语法：arr.length

数组的索引：
    - 索引也叫下标，常用 index 表示，是指一个数据在数组中排在哪一个位置
    - 注意: 在所有语言里面，索引都是从0开始的
    - 索引与数组长度的关系： index = length - 1
    - 获取数组的某个元素：
        * 第一个元素是 arr[0] 
        * 最后一个元素是 arr[length-1]


引申并强调：数据类型之间存储的区别

    + JS数据类型的存储方式：栈、堆
        - 栈：存储基础数据类型
            * 直接在栈空间内存储一个数据
        - 堆：存储复杂数据类型
            * 先在堆里面开辟一个存储空间
            * 然后把数据存储在这个存储空间中
            * 最后把堆存储空间的地址赋值给栈里面的变量
    
    + 数据类型之间的比较：
        - 基本数据类型是"值"的比较，也叫"值传递"
        - 复杂数据类型是"地址"的比较，也叫"引用传递"

    + 两种数据类型的赋值
        - 简单数据类型
            * 举例：
              var a1 = 10;
              var a2 = a1;
              console.log(a1==a2)  // true  
              // 将a1的值复制了一份给a2
              a1 = 20;
              console.log(a1, a2)  // 20  10
              // 即使更改了a1的值为20，a2的值依旧是10，两者互不影响

        - 复杂数据类型
            * 举例：
            var arr1 = { name: 'tim' }
            var arr2 = arr1  // 实际是将arr1的地址赋值给了arr2
            arr2.age = 20  // 实际会改变同一个地址里的值
            console.log(arr1, arr2)  // 两个打印的结果都会有 name与age属性
            console.log(arr1==arr2)  // true  比较的是同一个地址

            * 比喻：
                - 相当于你租了一个房子，然后你同学想与你合租
                - 于是你把自己的钥匙配了一把给他
                - 所以你们都可以打开这个房子
                - 因此，如果你的同学买了一盆绿植
                - 当你回来的时候，会发现房间比之前多了一盆绿植
    
    + 两种数据类型作为函数参数
        - 简单数据类型
            * 举例：
                var a = 10; // 1、定义了一个变量a
                function fn(b){
                    b++;  // 11   3、b=10 b++ = 11
                }
                fn(a);  // 2、将变量a的值赋值给b，相当于复制了一份给b
                console.log(a); // 10  4、b的变化不会影响a

        - 复杂数据类型
            * 举例：
                var m = [1,2,3,4];  // 1、定义了一个数组m
                function fn2(n){
                    n[n.length] = "hello" // 3、n得到的是m的地址，修改时会改变m的值
                }
                fn2(m);  //  2、m保存的是地址，所以是将地址复制了一份给n
                console.log(m);  // 4、n新增了数据，所以m的值也会变 [1,2,3,4, "hello"]

```

#### 数组的常用方法
```js


```

